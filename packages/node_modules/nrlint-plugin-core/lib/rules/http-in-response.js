/**
 * Does HTTP-in node has corresponding HTTP-response node?
 * @param {FlowSet} afs complete flow set
 * @param {*} conf configuration for this rule. {name: "http-in-resp", severity: "warn"}
 * @param {*} cxt context
 * @returns {context, result: [{rule: "http-in-resp", ids: [flowid], name: "dangling-http-in/resp", severity: "warn", message: "dangling http-in node"}]}
 */
function checkHttpInResp(afs, conf, cxt) {
    afs.getAllNodesArray()
        .filter(e => e.type === 'http in')
        .filter(e => {
            const ds = afs.downstream(e.id);
            return ds.length === 0 || ds.every(i => afs.getNode(i).type != 'http response');
        })
        .forEach(e => {
            cxt.report({
                location: [e.id],
                message: "HTTP In has no path to HTTP Response"
            })
        });

    afs.getAllNodesArray()
        .filter(e => e.type==='http response')
        .filter(e => {
            const ds = afs.upstream(e.id);
            return ds.length === 0 || ds.every(i => afs.getNode(i).type != 'http in');
        })
        .forEach(e => {
            cxt.report({
                location: [e.id],
                message: "HTTP Response has no path from HTTP In"
            })
        });
}


module.exports = {
    meta: {
        type: "suggestion",
        severity: "warn",
        docs: {
            description: "ensure all HTTP In nodes reach an HTTP Response node"
        },
        schema: []
    },
    check: checkHttpInResp
};
